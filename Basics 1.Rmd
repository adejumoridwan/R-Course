---
title: "Basics"
author: "Adejumo Ridwan Suleiman"
output: html_document
date: '2022-06-09'
---
# The basics {#thebasics}
Let's start from the very beginning. This section is as an introduction to R. It will show you how to install and work with R and RStudio.

After working with the material in this section, you will be able to:

* Create reusable R scripts,
* Store data in R,
* Use functions in R to analyse data,
* Install add-on packages adding additional features to R,
* Compute descriptive statistics like the mean and the median,
* Do mathematical calculations,
* Create nice-looking plots, including scatterplots, boxplots, histograms and bar charts,
* Find errors in your code.

## Installing R and RStudio {#installation}
To download R, go to the R Project website

https://cran.r-project.org/mirrors.html

Choose a _download mirror_, i.e. a server to download the software from. I recommend choosing a mirror close to you. You can then choose to download R for either Linux^[For many Linux distributions, R is also available from the package management system.], Mac or Windows by following the corresponding links (Figure 2.1).


The version of R that you should download is called the (base) binary. Download and run it to install R. You may see mentions of 64-bit and 32-bit versions of R; if you have a modern computer (which in this case means a computer from 2010 or later), you should go with the 64-bit version.

You have now installed the R programming language. Working with it is easier with an _integrated development environment_, or IDE for short, which allows you to easily write, run and debug your code.

To download RStudio, go to the RStudio download page

https://rstudio.com/products/rstudio/download/#download

Click on the link to download the installer for your operating system, and then run it.

## A first look at RStudio

1. The _Environment_ panel, where a list of the data you have imported and created can be found.
2. The _Files_, _Plots_ and _Help_ panel, where you can see a list of available files, will be able to view graphs that you produce, and can find help documents for different parts of R.
3. The _Console_ panel, used for running code. This is where we'll start with the first few examples.
4. The _Script_ panel, used for writing code. This is where you'll spend most of your time working.

The _Console_ panel will contain R's startup message, which shows information about which version of R you're running

You can resize the panels as you like, either by clicking and dragging their borders or using the minimise/maximise buttons in the upper right corner of each panel.


## Running R code {#runningcode}
Everything that we do in R revolves around _code_. The code will contain instructions for how the computer should treat, analyse and manipulate.
```{r eval=FALSE}
1+1
```


```{r eval=FALSE}
2*2
1+2*3-5
```

As you can see, when you type the code into the Console panel and press Enter, R runs the code and returns an answer. 

#### Exercise
Use R to compute the product of the first ten integers


### R scripts
When working in the Console pane [I.e. when the Console panel is active and you see a blinking text cursor in it.], you can use the up arrow â†‘ on your keyboard to retrieve lines of code that you've previously used. There is however a much better way of working with R code: to put it in script files. These are files containing R code, that you can save and then run again whenever you like.

To create a new script file in RStudio, press Ctrl+Shift+N on your keyboard, or select _File > New File > R Script_ in the menu. This will open a new Script panel (or a new tab in the Script panel, in case it was already open). You can then start writing your code in the Script panel. For instance, try the following:

```{r eval=FALSE}
1+1
2*2
1+2*3-5
(1+2)*3-5
```

In the Script panel, when you press Enter, you insert a new line instead of running the code. That's because the Script panel is used for _writing_ code rather than _running_ it. To actually run the code, you must send it to the Console panel. This can be done in several ways. Let's give them a try to see which you prefer.

To run the entire script do one of the following:

* Press the Source button in the upper right corner of the Script panel.
* Press Ctrl+Shift+Enter on your keyboard.
* Press Ctrl+Alt+Enter on your keyboard to run the code without printing the code and its output in the Console.

To run a part of the script, first select the lines you wish to run, e.g. by highlighting them using your mouse. Then do one of the following:

* Press the Run button at the upper right corner of the Script panel.
* Press Ctrl+Enter on your keyboard (this is how I usually do it!).

To save your script, click the Save icon, choose _File > Save_ in the menu or press Ctrl+S. R script files should have the file extension `.R`, e.g. `My first R script.R`. Remember to save your work often, and to save your code for all the examples and exercises.



## Variables and functions
Of course, R is so much more than just a fancy calculator. To unlock its full potential, we need to discuss two key concepts: _variables_ (used for storing data) and _functions_ (used for doing things with the data).

### Storing data
Without data, no data analytics. So how can we store and read data in R? The answer is that we use _variables_. A variable is a name used to store data, so that we can refer to a dataset when we write code. As the name _variable_ implies, what is stored can change over time.

The code

```{r eval=FALSE}
x <- 4
```

is used to _assign_ the value `4` to the _variable_ `x`. It is read as "assign `4` to `x`". The `<-` part is made by writing a less than sign (`<`) and a hyphen (`-`) with no space between them^[In RStudio, you can also create the assignment operator `<-` by using the keyboard shortcut Alt+- (i.e. press Alt and the - button at the same time).].

If we now type `x` in the Console, R will return the answer `4`. Well, almost. In fact, R returns the following rather cryptic output:

```{eval=FALSE}
[1] 4
```

The meaning of the `4` is clear - it's a 4. We'll return to what the `[1]` part means soon.

Now that we've created a variable, called `x`, and assigned a value (4) to it, `x` will have the value 4 whenever we use it again. This works just like a mathematical formula, where we for instance can insert the value $x=4$ into the formula $x+1$. The following two lines of code will compute $x+1=4+1=5$ and $x+x=4+4=8$:

```{r eval=FALSE}
x + 1
x + x
```

Once we have assigned a value to `x`, it will appear in the Environment panel in RStudio, where you can see both the variable's name and its value.

The left-hand side of the assignment `x <- 4` is always the name of a variable, but the right-hand side can be any piece of code that creates some sort of object to be stored in the variable. For instance, we could perform a computation on the right-hand side and then store the result in the variable:

```{r eval=FALSE}
x <- 1 + 2 + 3 + 4
```

R first evaluates the entire right-hand side, which in this case amounts to computing 1+2+3+4, and then assigns the result (10) to `x`. Note that the value previously assigned to `x` (i.e. `4`) now has been replaced by `10`. After a piece of code has been run, the values of the variables affected by it will have changed. There is no way to revert the run and get that `4` back, save to rerun the code that generated it in the first place.

You'll notice that in the code above, I've added some spaces, for instance between the numbers and the plus signs. This is simply to improve readability. The code works just as well without spaces:

```{r eval=FALSE}
x<-1+2+3+4
```

or with spaces in some places but not in others:

```{r eval=FALSE}
x<- 1+2+3 + 4
```

However, you can not place a space in the middle of the `<-` arrow. The following will not assign a value to `x`:

```{r eval=FALSE}
x < - 1 + 2 + 3 + 4
```

Running that piece of code rendered the output `FALSE`. This is because `< -` with a space has a different meaning than `<-` in R.

In rare cases, you may want to switch the direction of the arrow, so that the variable names is on the right-hand side. This is called right-assignment and works just fine too:

```{r eval=FALSE}
2 + 2 -> y
```

Later on, we'll see plenty of examples where right-assignment comes in handy.

#### Exercise
Do the following using R:
1. Compute the sum 924+124 and assign the result to a variable named `a`.
2. Compute a*a


### What's in a name?
You now know how to assign values to variables. But what should you call your variables? Of course, you can follow the examples in the previous section and give your variables names like `x`, `y`, `a` and `b`. However, you don't have to use single-letter names, and for the sake of readability, it is often preferable to give your variables more informative names. Compare the following two code chunks:

```{r eval=FALSE}
y <- 100
z <- 20
x <- y - z
```

and

```{r eval=FALSE}
income <- 100
taxes <- 20
net_income <- income - taxes
```

```{r eval=FALSE}
#############################################################
#  This lovely little code snippet can be used to compute   #
#                   your net income.                        #
#############################################################
# Set income and taxes:
income <- 100  # Replace 100 with your income
taxes <- 20    # Replace 20 with how much taxes you pay
# Compute your net income:
net_income <- income - taxes
```

In the Script panel in RStudio, you can comment and uncomment (i.e. remove the `#` symbol) a row by pressing Ctrl+Shift+C on your keyboard. This is particularly useful if you wish to comment or uncomment several lines - simply select the lines and press Ctrl+Shift+C.


#### Exercise

1. What happens if you use an invalid character in a variable name? Try e.g. the following:
  
```{r eval=FALSE}
net income <- income - taxes
net-income <- income - taxes
ca$h <- income - taxes
```

2. What happens if you put R code as a comment? E.g.:

```{r eval=FALSE}
income <- 100
taxes <- 20
net_income <- income - taxes
# gross_income <- net_income + taxes
```

3. What happens if you remove a line break and replace it by a semicolon `;`? E.g.:

```{r eval=FALSE}
income <- 200; taxes <- 30
```

4. What happens if you do two assignments on the same line? E.g.:

```{r eval=FALSE}
income2 <- taxes2 <- 100
```


### Vectors and data frames
Almost invariably, you'll deal with more than one figure at a time in your analyses. For instance, we may have a list of the ages of customers at a bookstore:

$$28, 48, 47, 71, 22, 80, 48, 30, 31$$
Of course, we could store each observation in a separate variable:

```{r eval=FALSE}
age_person_1 <- 28
age_person_2 <- 48
age_person_3 <- 47
# ...and so on
```

...but this quickly becomes awkward. A much better solution is to store the entire list in just one variable. In R, such a list is called a _vector_. We can create a vector using the following code, where `c` stands for _combine_:

```{r eval=FALSE}
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
```

The numbers in the vector are called _elements_. We can treat the vector variable `age` just as we treated variables containing a single number. The difference is that the operations will apply to all elements in the list. So for instance, if we wish to express the ages in months rather than years, we can convert all ages to months using:

```{r eval=FALSE}
age_months <- age * 12
```

Most of the time, data will contain measurements of more than one quantity. In the case of our bookstore customers, we also have information about the amount of money they spent on their last purchase:

$$20, 59, 2, 12, 22, 160, 34, 34, 29$$

First, let's store this data in a vector:

```{r eval=FALSE}
purchase <- c(20, 59, 2, 12, 22, 160, 34, 34, 29)
```

It would be nice to combine these two vectors into a table, like we would do in a spreadsheet software such as Excel. That would allow us to look at relationships between the two vectors - perhaps we could find some interesting patterns? In R, tables of vectors are called _data frames_. We can combine the two vectors into a data frame as:

```{r eval=FALSE}
bookstore <- data.frame(age, purchase)
```

If you type `bookstore` into the Console, it will show a simply formatted table with the values of the two vectors (and row numbers):

```{r eval=FALSE}
> bookstore
  age purchase
1  28       20
2  48       59
3  47        2
4  71       12
5  22       22
6  80      160
7  48       34
8  30       34
9  31       29
```

A better way to look at the table may be to click on the variable name `bookstore` in the Environment panel, which will open the data frame in a spreadsheet format.

You will have noticed that R tends to print a `[1]` at the beginning of the line when we ask it to print the value of a variable:

```{r eval=FALSE}
> age
[1] 28 48 47 71 22 80 48 30 31
```

Why? Well, let's see what happens if we print a longer vector:

```{r eval=FALSE}
# When we enter data into a vector, we can put line breaks between
# the commas:
distances <- c(687, 5076, 7270, 967, 6364, 1683, 9394, 5712, 5206,
               4317, 9411, 5625, 9725, 4977, 2730, 5648, 3818, 8241,
               5547, 1637, 4428, 8584, 2962, 5729, 5325, 4370, 5989,
               9030, 5532, 9623)
distances
```

Depending on the size of your Console panel, R will require a different number of rows to display the data in `distances`. The output will look something like this:
```{r eval=FALSE}
> distances
 [1]  687 5076 7270  967 6364 1683 9394 5712 5206 4317 9411 5625 9725
[14] 4977 2730 5648 3818 8241 5547 1637 4428 8584 2962 5729 5325 4370
[27] 5989 9030 5532 9623
```

or, if you have a narrower panel.

```{r eval=FALSE}
> distances
 [1]  687 5076 7270  967 6364 1683 9394
 [8] 5712 5206 4317 9411 5625 9725 4977
[15] 2730 5648 3818 8241 5547 1637 4428
[22] 8584 2962 5729 5325 4370 5989 9030
[29] 5532 9623
```

The numbers within the square brackets - `[1]`, `[8]`, `[15]`, and so on - tell us which _elements_ of the vector that are printed first on each row. So in the latter example, the first element in the vector is `687`, the 8th element is `5712`, the 15th element is `2730`, and so forth. Those numbers, called the _indices_ of the elements, aren't exactly part of your data, but as we'll see later they are useful for keeping track of it.

```{r eval=FALSE}
x <- 4
x
```

renders the output

```{r eval=FALSE}
> x
[1] 4
```

tells us that `x` in fact is a vector, albeit with a single element. Almost everything in R is a vector, in one way or another.

Being able to put data on multiple lines when creating vectors is hugely useful, but can also cause problems if you forget to include the closing bracket `)`. Try running the following code, where the final bracket is missing, in your Console panel:

```{r eval=FALSE}
distances <- c(687, 5076, 7270, 967, 6364, 1683, 9394, 5712, 5206,
               4317, 9411, 5625, 9725, 4977, 2730, 5648, 3818, 8241,
               5547, 1637, 4428, 8584, 2962, 5729, 5325, 4370, 5989,
               9030, 5532, 9623
```

When you hit Enter, a new line starting with a `+` sign appears. This indicates that R doesn't think that your statement has finished. To finish it, type `)` in the Console and then press Enter.

Vectors and data frames are hugely important when working with data in R.

#### Exercise
Do the following:
1. Create two vectors, `height` and `weight`, containing the heights and weights of five fictional people (i.e. just make up some numbers!).
2. Combine your two vectors into a data frame.
You will use these vectors in.
3. Try creating a vector using `x <- 1:5`. What happens? What happens if you use `5:1` instead? How can you use this notation to create the vector $(1,2,3,4,5,4,3,2,1)$?


### Functions

You have some data. Great. But simply having data is not enough - you want to _do_ something with it. Perhaps you want to draw a graph, compute a mean value or apply some advanced statistical model to it. To do so, you will use a _function_.

A function is a ready-made set of instructions - code - that tells R to do something. There are thousands of functions in R. Typically, you insert a variable into the function, and it returns an answer. The code for doing this follows the pattern `function_name(variable_name)`. 

```{r eval=FALSE}
# Compute the mean age of bookstore customers
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
mean(age)
```

Note that the code follows the pattern `function_name(variable_name)`: the function's name is `mean` and the variable's name is `age`.

Some functions take more than one variable as input, and may also have additional _arguments_(or _parameters_) that you can use to control the behaviour of the function. One such example is `cor`, which computes the correlation between two variables:

```{r eval=FALSE}
# Compute the correlation between the variables age and purchase
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
purchase <- c(20, 59, 2, 12, 22, 160, 34, 34, 29)
cor(age, purchase)
```

The answer, $0.59$ means that there appears to be a fairly strong positive correlation between age and the purchase size, which implies that older customers tend to spend more. On the other hand, just by looking at the data we can see that the oldest customer - aged 80 - spent much more than anybody else - 160 monetary units. It can happen that such _outliers_ strongly influence the computation of the correlation. By default, `cor` uses the Pearson correlation formula, which is known to be sensitive to outliers. It is therefore of interest to also perform the computation using a formula that is more robust to outliers, such as the Spearman correlation. This can be done by passing an additional _argument_ to `cor`, telling it which method to use for the computation:

```{r eval=FALSE}
cor(age, purchase, method = "spearman")
```

The resulting correlation, $0.35$ is substantially lower than the previous result. Perhaps the correlation isn't all that strong after all.

So, how can we know what arguments to pass to a function? Luckily, we don't have to memorise all possible arguments for all functions. Instead, we can look at the _documentation_, i.e. help file, for a function that we are interested in. This is done by typing `?function_name` in the Console panel, or doing a web search for `R function_name`. To view the documentation for the `cor` function, type:

```{r eval=FALSE}
?cor
```

The documentation for R functions all follow the same pattern:

* _Description_: a short (and sometimes quite technical) description of what the function does.
* _Usage_: an abstract example of how the function is used in R code.
* _Arguments_: a list and description of the input arguments for the function.
* _Details_: further details about how the function works.
* _Value_: information about the output from the function.
* _Note_: additional comments from the function's author (not always included).
* _References_: references to papers or books related to the function (not always included).
* _See Also_: a list of related functions.
* _Examples_: practical (and sometimes less practical) examples of how to use the function.

The first time that you look at the documentation for an R function, all this information can be a bit overwhelming. Perhaps even more so for `cor`, which is a bit unusual in that it shares its documentation page with three other (heavily related) functions: `var`, `cov` and `cov2cor`. Let the section headlines guide you when you look at the documentation. What information are you looking for? If you're just looking for an example of how the function is used, scroll down to Examples. If you want to know what arguments are available, have a look at Usage and Arguments.

#### Exercise
Using the data you created in Exercise, do the following:
1. Compute the mean height of the people.
2. Compute the correlation between height and weight.

Do the following:
1. Read the documentation for the function `length`. What does it do? Apply it to your `height` vector.
2. Read the documentation for the function `sort`. What does it do? What does the argument `decreasing` (the values of which can be either `FALSE` or `TRUE`) do? Apply the function to your `weight` vector.


### Mathematical operations {#maths}
To perform addition, subtraction, multiplication and division in R, we can use the standard symbols `+`, `-`, `*`, `/`. As in mathematics, expressions within parentheses are evaluated first, and multiplication is performed before addition. So `1 + 2*(8/2)` is $1+2\cdot(8/2)=1+2\cdot 4=1+8=9$.

In addition to these basic arithmetic operators, R has a number of mathematical functions that you can apply to your variables, including square roots, logarithms and trigonometric functions. Below is an incomplete list, showing the syntax for using the functions on a variable `x`. Throughout, `a` is supposed to be a number.

* `abs(x)`: computes the absolute value $|x|$.
* `sqrt(x)`: computes $\sqrt{x}$.
* `log(x)`: computes the logarithm of $x$ with the natural number $e$ as the base.
* `log(x, base = a)`: computes the logarithm of $x$ with the number $a$ as the base.
* `a^x`: computes $a^x$.
* `exp(x)`: computes $e^x$.
* `sin(x)`: computes $\sin(x)$.
* `sum(x)`: when `x` is a vector $x=(x_1,x_2,x_3,\ldots,x_n)$, computes the sum of the elements of `x`: $\sum_{i=1}^nx_i$.
* `prod(x)`: when `x` is a vector $x=(x_1,x_2,x_3,\ldots,x_n)$, computes the product of the elements of `x`: $\prod_{i=1}^nx_i$.
* `pi`: a built-in variable with value $\pi$, the ratio of the circumference of a circle to its diameter.
* `x %% a`: computes $x$ modulo $a$.
* `factorial(x)`: computes $x!$.
* `choose(n,k)`: computes ${n}\choose{k}$.

```{exercise, label="ch2bexc7"}
Compute the following:
1. $\sqrt{\pi}$
2. $e^2\cdot log(4)$
```


#### Exercise
R will return non-numerical answers if you try to perform computations where the answer is infinite or undefined. Try the following to see some possible results:
1. Compute $1/0$.
2. Compute $0/0$.
3. Compute $\sqrt{-1}$.



## Packages
R comes with a ton of functions, but of course these cannot cover all possible things that you may want to do with your data. That's where _packages_ come in. Packages are collections of functions and datasets that add new features to R. Do you want to apply some obscure statistical test to your data? Plot your data on a map?  Speed up some part of your data handling process? There are R packages for that. In fact, with more than 17,000 packages and counting, there are R packages for just about anything that you could possibly want to do. All packages have been contributed by the R community - that is, by users like you and me.

Most R packages are available from CRAN, the official R repository - a network of servers around the world. Packages on CRAN are checked before they are published, to make sure that they do what they are supposed to do and don't contain malicious components. Downloading packages from CRAN is therefore generally considered to be safe.

In the rest of this section, we'll make use of a package called `ggplot2`, which adds additional graphical features to R. To install the package from CRAN, you can either select _Tools > Install packages_ in the RStudio menu and then write `ggplot2` in the text box in the pop-up window that appears, or use the following line of code:

```{r eval=FALSE}
install.packages("ggplot2")
```

A menu may appear where you are asked to select the location of the CRAN mirror to download from. Pick the one the closest to you, or just use the default option - your choice can affect the download speed, but will in most cases not make much difference. There may also be a message asking whether to create a folder for your packages, which you should agree to do.

As R downloads and installs the packages, a number of technical messages are printed in the Console panel (an example of what these messages can look like during a successful installation is found in Section. `ggplot2` depends on a number of packages that R will install for you, so expect this to take a few minutes. If the installation finishes successfully, it will finish with a message saying:

```{r eval=FALSE}
* DONE (ggplot2)
```

Or, on some systems,

```{r eval=FALSE}
package â€˜ggplot2â€™ successfully unpacked and MD5 sums checked
```

If the installation fails for some reason, there will usually be a (sometimes cryptic) error message. You can read more about troubleshooting errors in SectionZ. There is also a list of common problems when installing packages available on the RStudio support page at https://support.rstudio.com/hc/en-us/articles/200554786-Problem-Installing-Packages.

After you've installed the package, you're still not finished quite yet. The package may have been installed, but its functions and datasets won't be available until you _load_ it. This is something that you need to do each time that you start a new R session. Luckily, it is done with a single short line of code using the `library` The use of `library` causes people to erroneously refer to R packages as _libraries_. Think of the library as the place where you store your packages, and calling `library` means that you go to your library to fetch the package, that I recommend putting at the top of your script file:

```{r eval=FALSE}
library(ggplot2)
```


## Descriptive statistics {#descstats}
In the remainder of this chapter, we will study two datasets that are shipped with the `ggplot2` package:

* `diamonds`: describing the prices of more than 50,000 cut diamonds.
* `msleep`: describing the sleep times of 83 mammals.

These, as well as some other datasets, are automatically loaded as data frames when you load `ggplot2`:

```{r eval=FALSE}
library(ggplot2)
```

To begin with, let's explore the `msleep` dataset. To have a first look at it, type the following in the Console panel

```{r eval=FALSE}
msleep
```

That shows you the first 10 rows of the data, and some of its columns. It also gives another important piece of information: `83 x 11`, meaning that the dataset has 83 rows (i.e. 83 observations) and 11 columns (with each column corresponding to a variable in the dataset).

There are however better methods for looking at the data. To view all 83 rows and all 11 variables, use:

```{r eval=FALSE}
View(msleep)
```

You'll notice that some cells have the value `NA` instead of a proper value. `NA` stands for Not Available, and is a placeholder used by R to point out _missing data_. In this case, it means that the value is unknown for the animal.

To find information about the data frame containing the data, some useful functions are:

```{r eval=FALSE}
head(msleep)
tail(msleep)
dim(msleep)
str(msleep)
names(msleep)
```

`dim` returns the numbers of rows and columns of the data frame, whereas `str` returns information about the 11 variables. Of particular importance are the _data types_ of the variables (`chr` and `num`, in this instance), which tells us what kind of data we are dealing with (numerical, categorical, dates, or something else). We'll delve deeper into data types in later sections. Finally, `names` returns a vector containing the names of the variables.

Like functions, datasets that come with packages have documentation describing them. The documentation for `msleep` gives a short description of the data and its variables. Read it to learn a bit more about the variables:

```{r eval=FALSE}
?msleep
```

Finally, you'll notice that `msleep` isn't listed among the variables in the Environment panel in RStudio. To include it there, you can:

```{r eval=FALSE}
data(msleep)
```

### Numerical data
Now that we know what each variable represents, it's time to compute some statistics. A convenient way to get some descriptive statistics giving a summary of each variable is to use the `summary` function:

```{r eval=FALSE}
summary(msleep)
```

For the text variables, this doesn't provide any information at the moment. But for the numerical variables, it provides a lot of useful information. For the variable `sleep_rem`, for instance, we have the following:

```{r eval=FALSE}
  sleep_rem  
Min.   :0.100
1st Qu.:0.900
Median :1.500
Mean   :1.875
3rd Qu.:2.400
Max.   :6.600
NA's   :22
```
This tells us that the mean of `sleep_rem` is `1.875`, that smallest value  is `0.100` and that the largest is `6.600`. The 1st quartile^[The first quartile is a value such that 25 % of the observations are smaller than it; the 3rd quartile is a value such that 25% of the observations are larger than it.] is `0.900`, the median is `1.500` and the third quartile is `2.400`. Finally, there are 22 animals for which there are no values (missing data - represented by `NA`).
Sometimes we want to compute just one of these, and other times we may want to compute summary statistics not included in `summary`. Let's say that we want to compute some descriptive statistics for the `sleep_total` variable. To access a vector inside a data frame, we use a dollar sign: `data_frame_name$vector_name`. So to access the `sleep_total` vector in the `msleep` data frame, we write:
```{r eval=FALSE}
msleep$sleep_total
```

Some examples of functions that can be used to compute descriptive statistics for this vector are:

```{r eval=FALSE}
mean(msleep$sleep_total)      # Mean
median(msleep$sleep_total)    # Median
max(msleep$sleep_total)       # Max
min(msleep$sleep_total)       # Min
sd(msleep$sleep_total)        # Standard deviation
var(msleep$sleep_total)       # Variance
quantile(msleep$sleep_total)  # Various quantiles
```

To see how many animals sleep for more than 8 hours a day, we can use the following:

```{r eval=FALSE}
sum(msleep$sleep_total > 8)   # Frequency (count)
mean(msleep$sleep_total > 8)  # Relative frequency (proportion)
```

`msleep$sleep_total > 8` checks whether the total sleep time of each animal is greater than 8.

Now, let's try to compute the mean value for the length of REM sleep for the animals:

```{r eval=FALSE}
mean(msleep$sleep_rem)
```

The above call returns the answer `NA`. The reason is that there are `NA` values in the `sleep_rem` vector (22 of them, as we saw before). What we actually wanted was the mean value among the animals for which we know the REM sleep. We can have a look at the documentation for `mean` to see if there is some way we can get this:

```{r eval=FALSE}
?mean
```

The argument `na.rm` looks promising - it is "a logical value indicating whether NA values should be stripped before the computation proceeds". In other words, it tells R whether or not to ignore the `NA` values when computing the mean. In order to ignore `NA`:s in the computation, we set `na.rm = TRUE` in the function cal:

```{r eval=FALSE}
mean(msleep$sleep_rem, na.rm = TRUE)
```

Note that the `NA` values have not been removed from `msleep`. Setting `na.rm = TRUE` simply tells R to ignore them in a particular computation, not to delete them.

We run into the same problem if we try to compute the correlation between `sleep_total` and `sleep_rem`:

```{r eval=FALSE}
cor(msleep$sleep_total, msleep$sleep_rem)
```

A quick look at the documentation (`?cor`), tells us that the argument used to ignore `NA` values has a different name for `cor` - it's not `na.rm` but `use`. The reason will become evident later on, when we study more than two variables at a time. For now, we set `use = "complete.obs"` to compute the correlation using only observations with complete data (i.e. no missing values):

```{r eval=FALSE}
cor(msleep$sleep_total, msleep$sleep_rem, use = "complete.obs")
```


### Categorical data {#catdata1}
Some of the variables, like `vore` (feeding behaviour) and `conservation` (conservation status) are _categorical_ rather than _numerical_. It therefore makes no sense to compute means or largest values. For categorical variables (often called _factors_ in R),  we can instead create a table showing the frequencies of different categories using `table`:

```{r eval=FALSE}
table(msleep$vore)
```

To instead show the proportion of different categories, we can apply `proportions` to the table that we just created:

```{r eval=FALSE}
proportions(table(msleep$vore))
```

The `table` function can also be used to construct a cross table that shows the counts for different combinations of two categorical variables:

```{r eval=FALSE}
# Counts:
table(msleep$vore, msleep$conservation)
# Proportions, per row:
proportions(table(msleep$vore, msleep$conservation),
            margin = 1)
# Proportions, per column:
proportions(table(msleep$vore, msleep$conservation),
            margin = 2)
```

#### Exercise

Load `ggplot2` using `library(ggplot2)` if you have not already done so. Then do the following:
1. View the documentation for the `diamonds` data and read about different the variables.
2. Check the data structures: how many observations and variables are there and what type of variables (numeric, categorical, etc.) are there?
3. Compute summary statistics (means, median, min, max, counts for categorical variables). Are there any missing values?

## Plotting numerical data
There are several different approaches to creating plots with R. In this sections, we will mainly focus on creating plots using the `ggplot2` package, which allows us to create good-looking plots using the so-called _grammar of graphics_. The grammar of graphics is a set of structural rules that helps us establish a language for graphics. The beauty of this is that (almost) all plots will be created with functions that all follow the same logic, or grammar. That way, we don't have to learn new arguments for each new plot. You can compare this to the problems we encountered when we wanted to ignore `NA` values when computing descriptive statistics - `mean` required the argument `na.rm` whereas `cor` required the argument `use`. By using a common grammar for all plots, we reduce the number of arguments that we need to learn.\index{numerical data}

The three key components to grammar of graphics plots are:

* **Data**: the observations in your dataset.
* **Aesthetics**: mappings from the data to visual properties (like axes and sizes of geometric objects), and
* **Geoms**: geometric objects, e.g. lines, representing what you see in the plot.

When we create plots using `ggplot2`, we must define what data, aesthetics and geoms to use. If that sounds a bit strange, it will hopefully become a lot clearer once we have a look at some examples. To begin with, we will illustrate how this works by visualising some continuous variables in the `msleep` data.

### Our first plot
As a first example, let's make a scatterplot by plotting the total sleep time of an animal against the REM sleep time of an animal.

Using base R, we simply do a call to the `plot` function in a way that is analogous to how we'd use e.g. `cor`:

```{r eval=FALSE}
plot(msleep$sleep_total, msleep$sleep_rem)
```

The code for doing this using `ggplot2` is more verbose:

```{r warning = FALSE, message = FALSE, fig.align = "center", fig.cap = "A scatterplot of mammal sleeping times."}
library(ggplot2)
ggplot(msleep, aes(x = sleep_total, y = sleep_rem)) + geom_point()
```

The code consists of three parts:

* **Data**: given by the first argument in the call to `ggplot`: `msleep`
* **Aesthetics**: given by the second argument in the `ggplot` call: `aes`, where we map `sleep_total` to the x-axis and `sleep_rem` to the y-axis.
* **Geoms**: given by `geom_point`, meaning that the observations will be represented by points.

At this point you may ask why on earth anyone would ever want to use `ggplot2` code for creating plots. It's a valid question. The base R code looks simpler, and is consistent with other functions that we've seen. The `ggplot2` code looks... different. This is because it uses the _grammar of graphics_, which in many ways is a language of its own, different from how we otherwise work with R.

But, the plot created using `ggplot2` also looked different. It used filled circles instead of empty circles for plotting the points, and had a grid in the background. In both base R graphics and `ggplot2` we can changes these settings, and many others. We can create something similar to the `ggplot2` plot using base R as follows, using the `pch` argument and the `grid` function:

```{r eval=FALSE}
plot(msleep$sleep_total, msleep$sleep_rem, pch = 16)
grid()
```

The syntax used to create the `ggplot2` scatterplot was in essence `ggplot(data, aes) + geom`. All plots created using `ggplot2` follow this pattern, regardless of whether they are scatterplots, bar charts or something else. The plus sign in `ggplot(data, aes) + geom` is important, as it implies that we can add more geoms to the plot, for instance a trend line, and perhaps other things as well. We will return to that shortly.

Unless the user specifies otherwise, the first two arguments to `aes` will always be mapped to the `x` and `y` axes, meaning that we can simplify the code above by removing the `x =` and `y =` bits (at the cost of a slight reduction in readability). Moreover, it is considered good style to insert a line break after the `+` sign. The resulting code is:

```{r eval=FALSE}
ggplot(msleep, aes(sleep_total, sleep_rem)) +
      geom_point()
```

Note that this does not change the plot in any way - the difference is merely in the style of the code.

```{exercise, label="ch2exc2"}
Create a scatterplot with total sleeping time along the x-axis and time awake along the y-axis (using the `msleep` data). What pattern do you see? Can you explain it?
```


### Colours, shapes and axis labels
You now know how to make scatterplots, but if you plan to show your plot to someone else, there are probably a few changes that you'd like to make. For instance, it's usually a good idea to change the label for the x-axis from the variable name "sleep_total" to something like "Total sleep time (h)". This is done by using the `+` sign again, adding a call to `xlab` to the plot:

```{r eval=FALSE}
ggplot(msleep, aes(sleep_total, sleep_rem)) +
      geom_point() +
      xlab("Total sleep time (h)")
```

Note that the plus signs must be placed at the end of a row rather than at the beginning. To change the y-axis label, add `ylab` instead.

To change the colour of the points, you can set the colour in `geom_point`:

```{r eval=FALSE}
ggplot(msleep, aes(sleep_total, sleep_rem)) +
      geom_point(colour = "red") +
      xlab("Total sleep time (h)")
```

In addition to `"red"`, there are a few more colours that you can choose from. You can run `colors()` in the Console to see a list of the 657 colours that have names in R (examples of which include `"papayawhip"`, `"blanchedalmond"`, and `"cornsilk4"`), or use colour hex codes like `"#FF5733"`.

Alternatively, you may want to use the colours of the point to separate different categories. This is done by adding a `colour` argument to `aes`, since you are now mapping a data variable to a visual property. For instance, we can use the variable `vore` to show differences between herbivores, carnivores and omnivores:

```{r eval=FALSE}
ggplot(msleep, aes(sleep_total, sleep_rem, colour = vore)) +
      geom_point() +
      xlab("Total sleep time (h)")
```

What happens if we use a continuous variable, such as the sleep cycle length `sleep_cycle` to set the colour?

```{r eval=FALSE}
ggplot(msleep, aes(sleep_total, sleep_rem, colour = sleep_cycle)) +
      geom_point() +
      xlab("Total sleep time (h)")
```


```{exercise, label="ch2exc3"}
Using the `diamonds` data, do the following:
1. Create a scatterplot with carat along the x-axis and price along the y-axis. Change the x-axis label to read "Weight of the diamond (carat)" and the y-axis label to "Price (USD)". Use `cut` to set the colour of the points.
2. Try adding the argument `alpha = 1` to `geom_point`, i.e. `geom_point(alpha = 1)`. Does anything happen? Try changing the `1` to `0.5` and `0.25` and see how that affects the plot.
```

### Axis limits and scales
Next, assume that we wish to study the relationship between animals' brain sizes and their total sleep time. We create a scatterplot using:

```{r eval=FALSE}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      xlab("Brain weight") +
      ylab("Total sleep time")
```

There are two animals with brains that are much heavier than the rest (African elephant and Asian elephant). These outliers distort the plot, making it difficult to spot any patterns. We can try changing the x-axis to only go from 0 to 1.5 by adding `xlim` to the plot, to see if that improves it:

```{r eval=FALSE}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      xlab("Brain weight") +
      ylab("Total sleep time") +
      xlim(0, 1.5)
```

This is slightly better, but we still have a lot of points clustered near the y-axis, and some animals are now missing from the plot. If instead we wished to change the limits of the y-axis, we would have used `ylim` in the same fashion.

Another option is to rescale the x-axis by applying a log transform to the brain weights, which we can do directly in 

```{r eval=FALSE}
ggplot(msleep, aes(log(brainwt), sleep_total, colour = vore)) + 
      geom_point() +
      xlab("log(Brain weight)") +
      ylab("Total sleep time")
```

This is a better-looking scatterplot, with a weak declining trend. We didn't have to remove the outliers (the elephants) to create it, which is good. The downside is that the x-axis now has become difficult to interpret. A third option that mitigates this is to add `scale_x_log10` to the plot, which changes the scale of the x-axis to a $\log_{10}$ scale (which increases interpretability because the values shown at the ticks still are on the original x-scale).

```{r eval=FALSE}
ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + 
      geom_point() +
      xlab("Brain weight (logarithmic scale)") +
      ylab("Total sleep time") +
      scale_x_log10()
```


### Exercise
Using the `msleep` data, create a plot of log-transformed body weight versus log-transformed brain weight. Use total sleep time to set the colours of the points. Change the text on the axes to something informative.

### Boxplots
Another option for comparing groups is boxplots (also called box-and-whiskers plots). Using `ggplot2`, we create boxplots for animal sleep times, grouped by feeding behaviour, with `geom_boxplot`. Using base R, we use the `boxplot`} function instead:

```{r eval=FALSE}
# Base R:
boxplot(sleep_total ~ vore, data = msleep)
# ggplot2:
ggplot(msleep, aes(vore, sleep_total)) +
      geom_boxplot()
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.align = "center", fig.cap = "Boxplots showing mammal sleeping times."}
ggplot(msleep, aes(vore, sleep_total)) +
      geom_boxplot()
```

The boxes visualise important descriptive statistics for the different groups, similar to what we got using `summary`:

* _Median_: the thick black line inside the box.
* _First quartile_: the bottom of the box.
* _Third quartile_: the top of the box.
* _Minimum_: the end of the line ("whisker") that extends from the bottom of the box.
* _Maximum_: the end of the line that extends from the top of the box.
* _Outliers_: observations that deviate too much^[In this case, _too much_ means that they are more than 1.5 times the height of the box away from the edges of the box.] from the rest are shown as separate points. These outliers are not included in the computation of the median, quartiles and the extremes.

Note that just as for a scatterplot, the code consists of three parts:

* **Data**: given by the first argument in the call to `ggplot`: `msleep`
* **Aesthetics**: given by the second argument in the `ggplot` call: `aes`, where we map the group variable `vore` to the x-axis and the numerical variable `sleep_total` to the y-axis.
* **Geoms**: given by `geom_boxplot`, meaning that the data will be visualised with boxplots.

#### Exercise
Using the `diamonds` data, do the following:
1. Create boxplots of diamond prices, grouped by `cut`.
2. Read the documentation for `geom_boxplot`. How can you change the colours of the boxes and their outlines?
3. Replace `cut` by `reorder(cut, price, median)` in\index{\texttt{reorder}} the plot's aestethics. What does `reorder` do? What is the result?
4. Add `geom_jitter(size = 0.1, alpha = 0.2)` to\index{\texttt{geom\_jitter}} the plot. What happens?

### Histograms
To show the distribution of a continuous variable, we can use a histogram, in which the data is split into a number of bins and the number of observations in each bin is shown by a bar. The `ggplot2` code for histograms follows the same pattern as other plots, while the base R code uses the `hist` function:

```{r eval=FALSE}
# Base R:
hist(msleep$sleep_total)
# ggplot2:
ggplot(msleep, aes(sleep_total)) +
      geom_histogram()
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.align = "center", fig.cap = "A histogram for mammal sleeping times."}
ggplot(msleep, aes(sleep_total)) +
      geom_histogram()
```

As before, the three parts in the `ggplot2` code are:

* **Data**: given by the first argument in the call to `ggplot`: `msleep`
* **Aesthetics**: given by the second argument in the `ggplot` call: `aes`, where we map `sleep_total` to the x-axis.
* **Geoms**: given by `geom_histogram`, meaning that the data will be visualised by a histogram.

#### Exercise
Using the `diamonds` data, do the following:
  
1. Create a histogram of diamond prices.
2. Create histograms of diamond prices for different cuts, using facetting.
3. Add a suitable argument to `geom_histogram` to add black outlines around the bars^[Personally, I don't understand why anyone would ever plot histograms without outlines!].


## Plotting categorical data {#catdata2}
When visualizing categorical data, we typically try to show the counts, i.e. the number of observations, for each category. The most common plot for this type of data is the bar chart.

### Bar charts
Bar charts are discrete analogues to histograms, where the category counts are represented by bars. The code for creating them is:

```{r eval=FALSE}
# Base R
barplot(table(msleep$vore))
# ggplot2
ggplot(msleep, aes(vore)) +
      geom_bar()
```

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.align = "center", fig.cap = "A bar chart for the mammal sleep data."}
ggplot(msleep, aes(vore)) +
      geom_bar()
```

As always, the three parts in the `ggplot2` code are:

* **Data**: given by the first argument in the call to `ggplot`: `msleep`
* **Aesthetics**: given by the second argument in the `ggplot` call: `aes`, where we map `vore` to the x-axis.
* **Geoms**: given by `geom_bar`, meaning that the data will be visualised by a bar chart.

To create a stacked bar chart using `ggplot2`, we use map all groups to the same value on the x-axis and then map the different groups to different colours. This can be done as follows:

```{r eval=FALSE}
ggplot(msleep, aes(factor(1), fill = vore)) +
      geom_bar()
```

```{exercise, label="ch2exc9"}
Using the `diamonds` data, do the following:
  
1. Create a bar chart of diamond cuts.
2. Add different colours to the bars by adding a `fill` argument to `geom_bar`.
3. Check the documentation for `geom_bar`. How can you decrease the width of the bars?
4. Return to the code you used for part 1. Add `fill = clarity` to the `aes`. What happens?
5. Next, add `position = "dodge"` to `geom_bar`. What happens?
6. Return to the code you used for part 1. Add `coord_flip()` to the plot. What happens?
```



## Saving your plot
When you create a `ggplot2` plot, you can save it as a plot object in R:

```{r eval=FALSE}
library(ggplot2)
myPlot <- ggplot(msleep, aes(sleep_total, sleep_rem)) +
      geom_point()
```

To plot a saved plot object, just write its name:

```{r eval=FALSE}
myPlot
```

If you like, you can add things to the plot, just as before:

```{r eval=FALSE}
myPlot + xlab("I forgot to add a label!")
```

To save your plot object as an image file, use `ggsave`. The `width` and `height` arguments allows us to control the size of the figure (in inches, unless you specify otherwise using the `units` argument).

```{r eval=FALSE}
ggsave("filename.pdf", myPlot, width = 5, height = 5)
```

If you don't supply the name of a plot object, `ggsave` will save the last `ggplot2` plot you created.

In addition to pdf, you can save images e.g. as jpg, tif, eps, svg, and png files, simply by changing the file extension in the filename. Alternatively, graphics from both base R and `ggplot2` can be saved using the `pdf` and `png` functions, using to mark the end of the file:

```{r eval=FALSE}
pdf("filename.pdf", width = 5, height = 5)
myPlot
dev.off()
png("filename.png", width = 500, height = 500)
plot(msleep$sleep_total, msleep$sleep_rem)
dev.off()
```

Note that you also can save graphics by clicking on the Export button in the Plots panel in RStudio. Using code to save your plot is usually a better idea, because of reproducibility. At some point you'll want to go back and make changes to an old figure, and that will be much easier if you already have the code to export the graphic.

## Troubleshooting {#troubleshooting}
Every now and then R will throw an error message at you. Sometimes these will be informative and useful, as in this case:

```{r eval=FALSE}
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
means(age)
```

where R prints:

```{r eval=FALSE}
> means(age)
Error in means(age) : could not find function "means"
```

This tells us that the function that we are trying to use, `means` does not exist. There are two possible reasons for this: either we haven't loaded the package in which the function exists, or we have misspelt the function name. In our example the latter is true, the function that we really wanted to use was of course `mean` and not `means`.